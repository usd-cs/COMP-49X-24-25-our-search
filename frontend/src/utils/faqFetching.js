/**
 * @file faqFetching.js
 * @description defines functions that make requests to the backend to edit/save, add, and delete FAQs.
 *
 * The function parameters are used to help define what needs to be edited/saved, added,
 * or deleted, and what needs to happen once the requests succeed or fail.
 *
 * @author Natalie Jungquist
 */

import { FAQ_URL, TYPE_STUDENT, TYPE_ADMIN, TYPE_FACULTY, FETCH_STUDENT_FAQS_URL, FETCH_FACULTY_FAQS_URL, FETCH_ADMIN_FAQS_URL } from '../resources/constants'
import getDataFrom from './getDataFrom'

export const handleSave = async (type, id, editedQuestion, editedAnswer, FAQs, setFAQs, setEditingId, setError) => {
  try {
    const response = await fetch(FAQ_URL, {
      credentials: 'include',
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        id,
        type,
        question: editedQuestion,
        answer: editedAnswer
      })
    })

    if (!response.ok) {
      throw new Error(response.status)
    }

    setFAQs(FAQs.map(u =>
      u.id === id ? { ...u, question: editedQuestion, answer: editedAnswer } : u
    ))
    setError(null)
    setEditingId(null)
  } catch (error) {
    if (error.message === '400') {
      setError('Bad request.')
    } else {
      setError(`Unexpected error updating FAQ for ${type}.`)
    }
  }
}

export const handleAdd = async (type, newQuestion, newAnswer, setNewQuestion, setNewAnswer, setFAQs, setLoading, setError) => {
  if (!newQuestion.trim()) {
    setError('Error adding FAQ. Must have a question.')
    return
  }
  if (!newAnswer.trim()) {
    setError('Error adding FAQ. Must have an answer.')
    return
  }

  setLoading(true)

  try {
    const response = await fetch(FAQ_URL, {
      credentials: 'include',
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type,
        question: newQuestion,
        answer: newAnswer
      })
    })

    if (!response.ok) {
      throw new Error(response.status)
    }

    // Adding means the page needs to fetch again from the backend for the updated data.
    // The page needs to fetch again to know the id generated by the backend of the new resource.
    let newFAQsData
    switch (type) {
      case TYPE_STUDENT:
        newFAQsData = await getDataFrom(FETCH_STUDENT_FAQS_URL)
        break
      case TYPE_FACULTY:
        newFAQsData = await getDataFrom(FETCH_FACULTY_FAQS_URL)
        break
      case TYPE_ADMIN:
        newFAQsData = await getDataFrom(FETCH_ADMIN_FAQS_URL)
        break
      default:
        break
    }

    if (newFAQsData.length === 0) {
      throw new Error('505')
    } else {
      setFAQs(newFAQsData)
    }

    setNewQuestion('')
    setNewAnswer('')
  } catch (error) {
    if (error.message === '400') {
      setError('Bad request.')
    } else if (error.message === '505') {
      setError(`FAQ added for ${type}, but there was an error loading updated data. Please refresh this page.`)
    } else {
      setError(`Unexpected error adding FAQ for ${type}.`)
    }
  } finally {
    setLoading(false)
  }
}

export const handleDelete = async (type, id, setLoading, FAQs, setFAQs, setDeletingId, setOpenDeleteDialog, setError) => {
  setLoading(true)

  const faqToDelete = FAQs.find(f => f.id === id)
  if (!faqToDelete) {
    setError('FAQ not found.')
    return
  }

  try {
    const response = await fetch(FAQ_URL, {
      credentials: 'include',
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type,
        id
      })
    })

    if (!response.ok) {
      throw new Error(response.status)
    }

    setFAQs(FAQs.filter(f => f.id !== id))
    setError(null)
    setDeletingId(null)
    setOpenDeleteDialog(false)
  } catch (error) {
    if (error.message === '400') {
      setError('Bad request.')
    } else {
      setError(`Unexpected error deleting FAQ for ${type}`)
    }
  } finally {
    setLoading(false)
  }
}
